Criptoanálisis de cifrados modulares
====

> Mariano Palomo Villafranca

## Descripción del problema
El cifrado modular o afín es una variante del cifrado de cesar, en el que introducimos dos parámetros en la llave, uno de ellos en forma multiplicativa.

Nuestro problema consiste en intentar obtener los parámetros de la llave (a y b) a partir, únicamente, del texto cifrado. Para ello, el **criptoanálisis** consistirá en analizar las distribuciones de la frecuencia de las letras y encontrar una asignación tentativa con la que resolver un sistema modular de 2 ecuaciones.

En primer lugar, tomaremos el texto cifrado y anotatemos la destribución de frecuencia dada en el mismo. A continuación, irémos realizando asignaciones en función de las frecuencias obtenidas y las letras más frecuentes en el idioma analizado (inglés en nuestro caso). Una vez hecho esto, intentaremos resolver el sistema y, si este tiene solución (a tiene inverso), trataremos de desencriptar el texto con los parámetros obtenidos y comprobar si se trata de un texto con sentido.

## Solución y descripción del algoritmo
Ya hemos indicado en qué consiste el problema, ahora veamos cómo abordarlo desde el punto de vista de la programación. Para ello, diseñaremos un algorimo: `break_affine(text, m)`, que recibe como entrada un texto cifrado y el número de letras que contiene el abecedario del idioma al que pertenece el texto llano. En nuestro caso, como se trata de inglés, `m` valdrá 26.

Para ello, nuestro algoritmo seguirá los siguientes pasos:

1. Contar las ocurrencias de caracteres en el texto y ordenarlas de mayor a menor
2. Realizar todas las posibles asignaciones de las letras obtenidas con las letras más comunes del idioma.
3. Resolver el sistema dado para cada asignación.
4. Si el sistema tiene solución, descifrar el texto con los valores de `a` y `b` obtenidos.
5. Comprobar si el texto obtenido tiene sentido en el idioma elegido (inglés) y, en caso de tenerlo, mostrar dicho texto y la pareja de valores `a` y `b`. Volver al paso 3 hasta que se hayan evaluado todas las asignaciones.

Para el diseño del algoritmo, se han programado funciones adifionales como son:

- `lcm(a, b)`: implementación del cálculo del mínimo común múltiplo de a y b.
- `extended_gcd`: adaptación del cálculo del máximo común divisor para el cálculo del inverso modular.
- `mod_inv(a, b)`: implementación del cáldulo del inverso modular.
- `system_solver(a1, a2, a3, b1, b2, b3, m)`: implementación de la resolución de sistemas modulares de 2 ecuaciones.
- `char_count(text)`: contador de caracteres del texto `text`.
- `decipher(text, a, b, m)`: implementación del desencriptado de un cifrado modular, conocidos `a` y `b`.

Además, hacemos uso de un par de funciones auxiliares, descargadas de internet, que nos facilitan la tarea de eliminar los espacios del texto y detectar textos en inglés: `infer_spaces(s)` y `isEnglish(message)`.

## Ejemplo de uso
El algoritmo ha sido programado en python y, a continuación se muestra un ejemplo de uso del programa. Tener en cuenta que el texto a descifrar debe introducirse en la función `main`  dentro de la variable `text`, que es de tipo String.

Para este ejemplo, la variable `text` contendrá el siguiente texto:

```python
text = 'WZDUY ZZYQB OTHTX ZDNZD KWQHI BYQBP WZDUY ZXZDSS'
```

Para ejecutar el programa, escribimos en la terminal:

```
$ python breakAffine.py
do unto others as you would have them do unto you xx -> a=5;b=7; Z=O;Y=T
do unto others as you would have them do unto you xx -> a=5;b=7; Z=O;U=N
do unto others as you would have them do unto you xx -> a=5;b=7; Z=O;O=R
do unto others as you would have them do unto you xx -> a=5;b=7; Y=T;Z=O
do unto others as you would have them do unto you xx -> a=5;b=7; Y=T;B=E
do unto others as you would have them do unto you xx -> a=5;b=7; Y=T;H=A
do unto others as you would have them do unto you xx -> a=5;b=7; B=E;Y=T
do unto others as you would have them do unto you xx -> a=5;b=7; B=E;U=N
do unto others as you would have them do unto you xx -> a=5;b=7; H=A;Y=T
do unto others as you would have them do unto you xx -> a=5;b=7; H=A;O=R
do unto others as you would have them do unto you xx -> a=5;b=7; U=N;Z=O
do unto others as you would have them do unto you xx -> a=5;b=7; U=N;B=E
do unto others as you would have them do unto you xx -> a=5;b=7; O=R;Z=O
do unto others as you would have them do unto you xx -> a=5;b=7; O=R;H=A
```
Como vemos, el programa reconoce, de entre todas las opciones, cual de ellas es un texto en inglés y lo representa ya descifrado y con sus respectivos espacios, además de indicar cuales son los a y b con los que se cifró y la asignación de letras a partir de las cuales se ha resulto el sistema.

## Código fuente
### `breakAffine.py`
```python
#!/usr/bin/python
# -*- coding: utf-8 -*-

# Seguridad y Protección de Sistemas de Información (SPSI)
# Copyright (C) 2015 - MPVillafranca (mpvillafranca@correo.ugr.es)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Este programa descifra textos cifrados mediante cifrado modular.

import fractions
import itertools
from detectEnglish import *
from inferSpaces import *

# Variables globales
L = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'  # Abecedario inglés [Ordenado] -> 26
F = 'ETRINOA'  # Letras más frecuentes del abecedario inglés en orden


def lcm(a, b):
    """Función que calcula el minimo común múltiplo de a y b"""
    return abs(a * b) / fractions.gcd(a, b) if a and b else 0


def extended_gcd(a, b):
    """Adaptación del cálculo del máximo común divisor para el cálculo del
    inverso modular"""
    lastremainder, remainder = abs(a), abs(b)
    x, lastx, y, lasty = 0, 1, 1, 0
    while remainder:
        lastremainder, (quotient, remainder) = remainder, \
            divmod(lastremainder, remainder)
        x, lastx = lastx - quotient*x, x
        y, lasty = lasty - quotient*y, y
    return lastremainder, lastx * (-1 if a < 0 else 1), \
        lasty * (-1 if b < 0 else 1)


def mod_inv(a, m):
    """Función que calcula el inverso de a (mod m)"""
    g, x, y = extended_gcd(a, m)
    if g != 1:  # Si mcd(a,m)!=1
        return -1  # Error, no existe inverso
    else:
        return x % m  # Inverso


def system_solver(a1, a2, a3, b1, b2, b3, m):
    """Función que resuelve el sistema a1=a2*a+a3*b; b1=b2*a+b3*b, mod m"""
    lcmvar = lcm(a3, b3)  # Calculamos el mcm de los coedicientes de la b
    aux1 = lcmvar / a3
    aux2 = lcmvar / b3
    a1 = (a1 * aux1) % m  # Multiplicamos la primera ecuación
    a2 = (a2 * aux1) % m
    a3 = (a3 * aux1) % m
    b1 = (b1 * aux2) % m  # Multiplicamos la segunda ecuación
    b2 = (b2 * aux2) % m
    b3 = (b3 * aux2) % m

    c1 = b1 - a1  # Restamos a la segunda ecuación la primera
    c2 = b2 - a2

    # Calculamos el inverso del coeficiente de la a, mod m
    inv = mod_inv(c2, m)
    if inv != -1:
        a = (c1 * inv) % m  # Calculamos a
        b = (a1 - (a2 * a)) % m	 # Calculamos b
    else:
        a = -1
        b = -1

    return a, b


def char_count(text):
    """Función que cuenta la cantidad de cada letra de un texto y lo almacena
    en un array"""
    occurrences = []
    i = 0
    for c in L:  # Recorremos el abecedario letra a letra
        # Por cada letra comprobamos cuantas veces aparece en el texto
        s = text.count(c)
        occurrences.append(s)  # Almacenamos el valor en un array
    return occurrences


def decipher(text, a, b, m):
    """Función que descifra un texto cifrado con cifrado modular, pasándole
    los valores a y b de la clave y el número de letras del alfabeto"""
    detext = ""
    for c in text:
        if (ord(c) - 65) != -33:
            newc = (((ord(c) - 65) - b) * mod_inv(a, m)) % m  # Caracteres
        else:
            newc = ord(c) - 65  # Espacios
        newc = chr(newc + 65)
        detext = detext + newc
    return detext


def break_affine(text, m):
    """Función que rompe el cifrado modular de un texto"""
    occurrences = char_count(text)
    sorted_occurrences = []
    for i in sorted(occurrences, reverse=True):
        aux = occurrences.index(i)
        if aux != 0:
            occurrences[occurrences.index(i)] = -1
            auxlist = [str(unichr(aux + 65)), i]
            sorted_occurrences.append(auxlist)

    Ffix = [(ord(c) - 65) for c in F]

    auxsorted = []
    for i in range(len(sorted_occurrences)):
        auxsorted.append(sorted_occurrences[i][0])

    auxF = []
    for c in F:
        auxF.append(c)

    auxproduct = [auxsorted, auxF]
    for element in itertools.product(*auxproduct):
        for element2 in itertools.product(*auxproduct):
            if element[0] != element2[0] and element[1] != element2[1]:
                a1 = ord(element[0])-65
                a2 = ord(element[1])-65
                b1 = ord(element2[0])-65
                b2 = ord(element2[1])-65
                a, b = system_solver(a1, a2, 1, b1, b2, 1, m)
                if a != -1 and b != -1:
                    detext = decipher(text, a, b, m)
                    if isEnglish(detext):
                        print infer_spaces(detext.lower()) + " -> a=" + str(a) + \
                            ";b=" + str(b) + "; " + \
                            element[0] + "=" + element[1] + ";" + \
                            element2[0] + "=" + element2[1]


def main():
    text = 'WZDUY ZZYQB OTHTX ZDNZD KWQHI BYQBP WZDUY ZXZDSS'
    text = text.replace(" ", "")
    break_affine(text, len(L))


# Lanzamos la ejecución
if __name__ == "__main__":
    main()

```

### `inferSpaces.py`

```python
from math import log

# Build a cost dictionary, assuming Zipf's law and cost = -math.log(probability).
words = open("words-by-frequency.txt").read().split()
wordcost = dict((k, log((i+1)*log(len(words)))) for i,k in enumerate(words))
maxword = max(len(x) for x in words)

def infer_spaces(s):
    """Uses dynamic programming to infer the location of spaces in a string
    without spaces."""

    s = s.lower()

    # Find the best match for the i first characters, assuming cost has
    # been built for the i-1 first characters.
    # Returns a pair (match_cost, match_length).
    def best_match(i):
        candidates = enumerate(reversed(cost[max(0, i-maxword):i]))
        return min((c + wordcost.get(s[i-k-1:i], 9e999), k+1) for k,c in candidates)

    # Build the cost array.
    cost = [0]
    for i in range(1,len(s)+1):
        c,k = best_match(i)
        cost.append(c)

    # Backtrack to recover the minimal-cost string.
    out = []
    i = len(s)
    while i>0:
        c,k = best_match(i)
        assert c == cost[i]
        out.append(s[i-k:i])
        i -= k

    return " ".join(reversed(out))

```

### `detectEnglish.py`

```python
# Detect English module
# http://inventwithpython.com/hacking (BSD Licensed)
# Thanks to http://github.com/asweigart

# To use, type this code:
#   import detectEnglish
#   detectEnglish.isEnglish(someString) # returns True or False
# (There must be a "dictionary.txt" file in this directory with all English
# words in it, one word per line. You can download this from
# http://invpy.com/dictionary.txt)

from inferSpaces import infer_spaces

UPPERLETTERS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
LETTERS_AND_SPACE = UPPERLETTERS + UPPERLETTERS.lower() + ' \t\n'

def loadDictionary():
    dictionaryFile = open('dictionary.txt')
    englishWords = {}
    for word in dictionaryFile.read().split('\r\n'):
        englishWords[word] = None
    dictionaryFile.close()
    return englishWords

ENGLISH_WORDS = loadDictionary()


def getEnglishCount(message):
    message = infer_spaces(message)
    message = message.upper()
    message = removeNonLetters(message)
    possibleWords = message.split()

    if possibleWords == []:
        return 0.0 # no words at all, so return 0.0

    matches = 0
    for word in possibleWords:
        if word in ENGLISH_WORDS:
            matches += 1
    return float(matches) / len(possibleWords)


def removeNonLetters(message):
    lettersOnly = []
    for symbol in message:
        if symbol in LETTERS_AND_SPACE:
            lettersOnly.append(symbol)
    return ''.join(lettersOnly)


def isEnglish(message, wordPercentage=20, letterPercentage=85):
    # By default, 20% of the words must exist in the dictionary file, and
    # 85% of all the characters in the message must be letters or spaces
    # (not punctuation or numbers).
    wordsMatch = getEnglishCount(message) * 100 >= wordPercentage
    numLetters = len(removeNonLetters(message))
    messageLettersPercentage = float(numLetters) / len(message) * 100
    lettersMatch = messageLettersPercentage >= letterPercentage
    return wordsMatch and lettersMatch
```
## Referencias
1. Cifrado afín: [https://es.wikipedia.org/wiki/Cifrado_af%C3%ADn](https://es.wikipedia.org/wiki/Cifrado_af%C3%ADn)

2. Google-1000-English: [https://github.com/first20hours/google-10000-english/edit/master/google-10000-english.txt](https://github.com/first20hours/google-10000-english/edit/master/google-10000-english.txt)

3. Stackoverflow - How to split text without spaces into list of words: [http://stackoverflow.com/questions/8870261/how-to-split-text-without-spaces-into-list-of-words](http://stackoverflow.com/questions/8870261/how-to-split-text-without-spaces-into-list-of-words)

4. Invent with Python - hacking: [http://inventwithpython.com/hacking](http://inventwithpython.com/hacking)

5. Asweigart - Codebreaker Repository: [https://github.com/asweigart/codebreaker](https://github.com/asweigart/codebreaker)

6. English dictionary: [http://invpy.com/dictionary.txt](http://invpy.com/dictionary.txt)
